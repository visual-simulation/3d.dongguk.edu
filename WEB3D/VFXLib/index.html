<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>

    <script src="./lib/three/build/three.min.js"></script>
    <script src="./ParticleSystemGPU.js"></script>


</head>
<body>

    <script>

        var vertexShaderSource = loadShaderFile("./drawShader.vert.glsl");
        var fragmentShaderSource = loadShaderFile("./drawShader.frag.glsl");

        var scene, camera, renderer;
        var mesh;
        var ps;

        var geometry;


        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xaaaaaa);

            document.body.appendChild(renderer.domElement);

            //

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.z = 400;

            scene = new THREE.Scene();

/*
            var geometry = new THREE.BoxGeometry( 200, 200, 200 );

            var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
            texture.anisotropy = renderer.getMaxAnisotropy();

            var material = new THREE.MeshBasicMaterial( { map: rtTexture } );

            mesh = new THREE.Mesh( geometry, material );
            mesh.needsUpdate = true;
            scene.add( mesh );
*/
            //

            window.addEventListener( 'resize', onWindowResize, false );


            // Initialize Particles
            ps = new ParticleSystemGPU();
            //ps.initialize(renderer);

            ps.initialize(10000, renderer, camera);

            var cen = new THREE.Vector3(0,0,0);
            var rad = 200;

            for(var i=0; i<10000; i++) {

                var pos = new THREE.Vector3((Math.random()-0.5)*2.0*rad, (Math.random()-0.5)*2.0*rad, (Math.random()-0.5)*2.0*rad);
                var vel = new THREE.Vector3(0.0, 10.0, 0.0);

                if(pos.distanceTo(cen) < rad) {

                   ps.addParticle(pos, vel);

                }
            }

            ps.initializeShaderMaterials();

            geometry = new THREE.BufferGeometry();

            var material = new THREE.PointCloudMaterial( { size: 4, vertexColors: THREE.VertexColors } );

            var shaderMaterial = new THREE.RawShaderMaterial({
                vertexShader : vertexShaderSource,
                fragmentShader : fragmentShaderSource
            });


            points = new THREE.PointCloud(geometry);
            //scene.add(points);

            points.material = shaderMaterial;
            points.geometry.addAttribute('position', new THREE.BufferAttribute(ps.positions,3));




        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            requestAnimationFrame( animate );

            //mesh.rotation.x += 0.005;
            //mesh.rotation.y += 0.01;

            //ps.updateParticles(0.1);

            // renderer.render( sceneRTT, cameraRTT, rtTexture, true);

            //ps.advectParticles(0.01);

            //points.geometry.addAttribute('position', new THREE.BufferAttribute(ps.positions, 3));

            ps.assignParticles();
            ps.drawParticles(scene, camera);

            //renderer.render( scene, camera );
         }

        init();

        animate();

    </script>

</body>
</html>