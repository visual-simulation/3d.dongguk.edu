<!DOCTYPE html>

<html>

<head>
    <title>sample</title>
    <script src="./lib/three/build/three.js"></script>
    <script src="./lib/three/examples/js/libs/stats.min.js"></script>
    <script type="text/javascript" src="./dat.gui.min.js"></script>
    <script src="./lib/three/examples/js/controls/OrbitControls.js"></script>
    <script src="./ParticleSystem.js"></script>
    <script src="./paticleParameter.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>
<script id="fragment_shh" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif

			uniform sampler2D tOne;
			uniform sampler2D tSec;
            uniform float alpha;
			varying vec2 vUv;

			void main(void)
			{
				vec3 c;
				vec4 Ca = texture2D(tOne, vUv);
				vec4 Cb = texture2D(tSec, vUv);
				Ca.a=1.0;
				Cb.a=alpha;
				c = Ca.rgb * Ca.a + Cb.rgb * Cb.a;
			    gl_FragColor= vec4(c, 1.0);
			}
</script>

<script id="vertex_shh" type="x-shader/x-vertex">
    varying vec2 vUv;
	#ifdef USE_SKINNING
	 	varying vec3 vViewPosition;
		varying vec3 vNormal;
		uniform mat4 bindMatrix;
		uniform mat4 bindMatrixInverse;
		uniform mat4 boneGlobalMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneGlobalMatrices[ int(i) ];
			return bone;
		}
	#endif
	void main() {
		vUv = uv;
		#ifdef USE_SKINNING
			mat4 boneMatX = getBoneMatrix( skinIndex.x );
			mat4 boneMatY = getBoneMatrix( skinIndex.y );
			mat4 boneMatZ = getBoneMatrix( skinIndex.z );
			mat4 boneMatW = getBoneMatrix( skinIndex.w );
			mat4 skinMatrix = mat4( 0.0 );
			skinMatrix += skinWeight.x * boneMatX;
			skinMatrix += skinWeight.y * boneMatY;
			skinMatrix += skinWeight.z * boneMatZ;
			skinMatrix += skinWeight.w * boneMatW;
			skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
			vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );
			vec3 objectNormal = skinnedNormal.xyz;
			vec3 transformedNormal = normalMatrix * objectNormal;
			vNormal = normalize( transformedNormal );
			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );
			vec4 skinned = vec4( 0.0 );
			skinned += boneMatX * skinVertex * skinWeight.x;
			skinned += boneMatY * skinVertex * skinWeight.y;
			skinned += boneMatZ * skinVertex * skinWeight.z;
			skinned += boneMatW * skinVertex * skinWeight.w;
			skinned  = bindMatrixInverse * skinned;
			vec4 mvPosition = modelViewMatrix * skinned;
		#else
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		#endif
		gl_Position = projectionMatrix * mvPosition;
	}

		</script>
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    var particleSystem = new ParticleSystem();
    particleSystem.initialize(1000);

    particleSystem.setParameters(Examples.snowStorm);
    particleSystem.setParameters({seedSize : 4.1});
    particleSystem.setParameters({seedVelMag : 100});
    particleSystem.setParameters({windStrength: 0.0});
    particleSystem.setParameters({seedLife : 1});


    var mesh,mesh1,mesh2;
    var material_shh,material_shh1,material_shh2,material_shh3;
    var scene,camera,webGLRenderer,textureGrass,texture,texture2,planeGeometry;

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);

        // create a render and set the size
        webGLRenderer = new THREE.WebGLRenderer();
        webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.shadowMapEnabled = true;

        // position and point the camera to the center of the scene
        camera.position.x = 100;
        camera.position.y = 100;
        camera.position.z = 50;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        textureGrass = THREE.ImageUtils.loadTexture("./textures/grass.jpg");
        textureGrass.wrapS = THREE.RepeatWrapping;
        textureGrass.wrapT = THREE.RepeatWrapping;
        textureGrass.repeat.set(4, 4);

        texture = THREE.ImageUtils.loadTexture("./textures/character.png");

        texture2= THREE.ImageUtils.loadTexture("./textures/snowflake.png");


        planeGeometry = new THREE.PlaneBufferGeometry(500, 500, 20, 20);
        var planeMaterial = new THREE.MeshLambertMaterial({map: textureGrass});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 15;
        plane.position.y = 0;
        plane.position.z = 0;

        // add the plane to the scene
        scene.add(plane);
        scene.add(particleSystem.getMesh());

        var orbitControls = new THREE.OrbitControls(camera);

        var spotLight0 = new THREE.DirectionalLight(0xefefff,2);
        spotLight0.position.set(1,1,1).normalize();
        scene.add(spotLight0);

        var spotLight1 = new THREE.DirectionalLight(0xefefff,2);
        spotLight1.position.set(-1,-1,-1).normalize();
        scene.add(spotLight1);

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);


        var vertShader = document.getElementById('vertex_shh').textContent;
        var fragShader = document.getElementById('fragment_shh').textContent;


        var times=20;
        var max,max1,max2,nax3;
        var min,min1,min2,min3;
        var alpha=0.0;
        var alpha1=0.0;
        var alpha2=0.0;
        var clock = new THREE.Clock();

        var loader = new THREE.JSONLoader();

        loader.load('./models/character.json', function (model) {

            material_shh = new THREE.ShaderMaterial({
                uniforms: {
                    tOne: { type: "t", value: texture },
                    tSec: { type: "t", value: texture2 },
                    alpha:{type:"f",value:alpha}
                },
                vertexShader: vertShader,
                fragmentShader: fragShader,
                transparent: true,
                skinning : true
            });


            mesh = new THREE.SkinnedMesh(model,material_shh,false);
            mesh.scale.set(times,times,times);
            //mesh.rotation.y = 90*Math.PI/180;
            mesh.position.z=20;
           // mesh.geometry.computeBoundingBox();

            var bbox = new THREE.BoundingBoxHelper( mesh, 0x00ff00 );
            bbox.update();

            var animation = new THREE.Animation(mesh, mesh.geometry.animations[0]);

            scene.add(mesh);

            // start the animation

            animation.play(40);

            max=bbox.box.max;
            min=bbox.box.min;

        }, './models/');


        loader.load('./models/character.json', function (model) {

            material_shh1 = new THREE.ShaderMaterial({
                uniforms: {
                    tOne: { type: "t", value: texture },
                    tSec: { type: "t", value: texture2 },
                    alpha:{type:"f",value:alpha1}
                },
                vertexShader: vertShader,
                fragmentShader: fragShader,
                transparent: true,
                skinning : true
            });


            mesh1 = new THREE.SkinnedMesh(model,material_shh1,false);
            mesh1.scale.set(times,times,times);
            mesh1.rotation.y = 90*Math.PI/180;
            mesh1.position.x=20;

            // mesh.geometry.computeBoundingBox();

            var bbox = new THREE.BoundingBoxHelper( mesh1, 0x00ff00 );
            bbox.update();

            var animation = new THREE.Animation(mesh1, mesh1.geometry.animations[0]);

            scene.add(mesh1);

            // start the animation
            animation.play(0);

            max1=bbox.box.max;
            min1=bbox.box.min;

        }, './models/');

        loader.load('./models/character.json', function (model) {

            material_shh2 = new THREE.ShaderMaterial({
                uniforms: {
                    tOne: { type: "t", value: texture },
                    tSec: { type: "t", value: texture2 },
                    alpha:{type:"f",value:alpha2}
                },
                vertexShader: vertShader,
                fragmentShader: fragShader,
                transparent: true,
                skinning : true
            });


            mesh2 = new THREE.SkinnedMesh(model,material_shh2,false);
            mesh2.scale.set(times,times,times);
            mesh2.rotation.y = 180*Math.PI/180;
            //mesh.position.x=-20;
            mesh2.position.z=-20;

            // mesh.geometry.computeBoundingBox();

            var bbox = new THREE.BoundingBoxHelper( mesh2, 0x00ff00 );
            bbox.update();

            var animation = new THREE.Animation(mesh2, mesh2.geometry.animations[0]);

            scene.add(mesh2);

            // start the animation
            animation.play(20);

            max2=bbox.box.max;
            min2=bbox.box.min;

        }, './models/');

        render();
        var time;

        function render() {
            stats.update();

            var delta = clock.getDelta();
            orbitControls.update(delta);

            var now = new Date().getTime();
            var dt = (now - (time||now))/1000;
            time = now;

            var cen = new THREE.Vector3(0,100,0);
            var nor = new THREE.Vector3(0,-1,0);
            var rad = 1000;

            particleSystem.addParticlesFromDisk(10, cen, nor, rad);
            particleSystem.updateParticles(dt);


            var count = particleSystem.getCount();

            for(var i=0; i<count; i++) {

                var p = particleSystem.getParticle(i).position;

                if(min != undefined && max != undefined) {

                    if(min.x <= p.x && min.y <= p.y && min.z <= p.z &&
                            max.x >= p.x && max.y >= p.y && max.z >= p.z ) {
                        if(alpha<1.0){
                            alpha+=0.001;

                            material_shh.uniforms.alpha = {type:"f",value:alpha};
                            material_shh.needsUpdate = true;
                            //THREE.AnimationHandler.update(dt);
                        }
                    }
                }
                if(min1 != undefined && max1 != undefined) {

                    if(min1.x <= p.x && min1.y <= p.y && min1.z <= p.z &&
                            max1.x >= p.x && max1.y >= p.y && max1.z >= p.z ) {
                        if(alpha1<1.0){
                            alpha1+=0.001;

                            material_shh1.uniforms.alpha = {type:"f",value:alpha1};
                            material_shh1.needsUpdate = true;
                            //THREE.AnimationHandler.update(dt);
                        }
                    }
                }
                if(min2 != undefined && max2 != undefined) {

                    if(min2.x <= p.x && min2.y <= p.y && min2.z <= p.z &&
                            max2.x >= p.x && max2.y >= p.y && max2.z >= p.z ) {
                        if(alpha2<1.0){
                            alpha2+=0.005;

                            material_shh2.uniforms.alpha = {type:"f",value:alpha2};
                            material_shh2.needsUpdate = true;
                            //THREE.AnimationHandler.update(dt);
                        }
                    }
                }
            }

            THREE.AnimationHandler.update(dt);

            requestAnimationFrame(render);
            // render using requestAnimationFrame
            webGLRenderer.render(scene, camera);
        }



        function initStats() {

            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    }
    window.onload = init;
</script>
</body>
</html>