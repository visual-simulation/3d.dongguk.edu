<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>

    <script src="./lib/three/build/three.min.js"></script>
    <script src="./ParticleSystem.js"></script>


</head>
<body>

    <script>

        var scene, camera, renderer;
        var mesh;
        var ps;

        var geometry;


        // render to texture
        var sceneRTT;
        var cameraRTT;
        var quadRTT;

        var rtWidth = 1024;
        var rtHeight = 1024;
        var rtTexture;

        //

        function initSceneRTT() {

            sceneRTT = new THREE.Scene();
            cameraRTT = new THREE.OrthographicCamera(rtWidth/-2, rtWidth/2, rtHeight/2, rtHeight/-2, -10000, 10000);
            cameraRTT.position.z = 100;

            rtTexture = new THREE.WebGLRenderTarget(rtWidth, rtHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat });

            var material = new THREE.MeshBasicMaterial( { color:0xff00ff } );

            var plane = new THREE.PlaneGeometry(rtWidth, rtHeight);
            quadRTT = new THREE.Mesh(plane, material);
         //   quadRTT.position.z = -100;

            sceneRTT.add(quadRTT);
        }

        function init() {

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xffffff);

            document.body.appendChild(renderer.domElement);

            //

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.z = 400;

            scene = new THREE.Scene();


/*
            var geometry = new THREE.BoxGeometry( 200, 200, 200 );

            var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
            texture.anisotropy = renderer.getMaxAnisotropy();

            var material = new THREE.MeshBasicMaterial( { map: rtTexture } );

            mesh = new THREE.Mesh( geometry, material );
            mesh.needsUpdate = true;
            scene.add( mesh );
*/
            //

            window.addEventListener( 'resize', onWindowResize, false );


            // Initialize Particles
            ps = new ParticleSystem();
            ps.initialize(renderer);

            var cen = new THREE.Vector3(0,0,0);
            var rad = 200;

            for(var i=0; i<1000; i++) {

                var pos = new THREE.Vector3((Math.random()-0.5)*2.0*rad, (Math.random()-0.5)*2.0*rad, (Math.random()-0.5)*2.0*rad);
                var vel = new THREE.Vector3(0.0, 10.0, 0.0);

                if(pos.distanceTo(cen) < rad) {

                   ps.addParticle(pos, vel);

                }
            }

            geometry = new THREE.BufferGeometry();
            var material = new THREE.PointCloudMaterial( { size: 4, vertexColors: THREE.VertexColors } );

            geometry.addAttribute('position', new THREE.BufferAttribute(ps.positions));
            geometry.addDrawCall(0, ps.particleCount, 0);

            points = new THREE.PointCloud(geometry, material);

            scene.add(points);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            requestAnimationFrame( animate );

            //mesh.rotation.x += 0.005;
            //mesh.rotation.y += 0.01;

            points.geometry.addAttribute('position', new THREE.BufferAttribute(ps.positions, 3));
            ps.updateParticles(0.1);


           // renderer.render( sceneRTT, cameraRTT, rtTexture, true);
            renderer.render( scene, camera );
         }


        initSceneRTT();
        init();


        animate();

    </script>

</body>
</html>